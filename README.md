# Competitive Programming Solutions

This repository contains solutions to various competitive programming problems. The solutions are implemented in C++ and cover a range of topics and algorithms. Each solution is well-documented and organized for easy understanding and usage.

## Contents

1. [Assignment 1 Solutions](#assignment-1-solutions)
2. [Assignment 2 Solutions](#assignment-2-solutions)
3. [Assignment 3 Solutions](#assignment-3-solutions)
4. [Assignment 4 Solutions](#assignment-4-solutions)

## Assignment 1 Solutions

### Solution 1: Finding Tree Edges (sol1.cpp)
- Description: This solution finds the tree edges and back edges in an undirected graph using Depth-First Search (DFS).
- [Code](sol1.cpp)

### Solution 2: Shortest Path in Unweighted Graph (sol2.cpp)
- Description: This solution calculates the shortest path from a given source vertex to all other vertices in an unweighted graph using Breadth-First Search (BFS).
- [Code](sol2.cpp)

### Solution 3: Finding Bridges and Articulation Points (sol3.cpp)
- Description: This solution finds bridges and articulation points in an undirected graph using Depth-First Search (DFS).
- [Code](sol3.cpp)

## Assignment 2 Solutions

### Solution 1: Topological Sorting (ass_2_sol_1.cpp)
- Description: This solution performs topological sorting on a directed acyclic graph (DAG).
- [Code](ass_2_sol_1.cpp)

### Solution 2A: Shortest Path Finding (ass_2_sol_2_a.cpp)
- Description: This solution finds the shortest path in a directed acyclic graph (DAG) using dynamic programming.
- [Code](ass_2_sol_2_a.cpp)

### Solution 2B: Longest Path Finding (ass_2_sol_2_b.cpp)
- Description: This solution finds the longest path in a directed acyclic graph (DAG) using dynamic programming.
- [Code](ass_2_sol_2_b.cpp)

### Solution 2C: Counting Number of Paths (ass_2_sol_2_c.cpp)
- Description: This solution counts the number of paths between two vertices in a directed acyclic graph (DAG) using dynamic programming.
- [Code](ass_2_sol_2_c.cpp)

### Solution 3: Strongly Connected Components (ass_2_sol_3.cpp)
- Description: This solution finds strongly connected components in a directed graph using Depth-First Search (DFS) and Kosaraju's algorithm.
- [Code](ass_2_sol_3.cpp)

### Solution 4: 2-SAT Problem (ass_2_sol_4.cpp)
- Description: This solution solves the 2-SAT problem using the Kosaraju's algorithm and assigns values to variables.
- [Code](ass_2_sol_4.cpp)

## Assignment 3 Solutions

### Solution 1: Union-Find Data Structure (ass_3_sol_1.cpp)
- Description: This solution implements the union-find data structure and performs union and find operations.
- [Code](ass_3_sol_1.cpp)

### Solution 2: Dynamic Union-Find Data Structure (ass_3_sol_2.cpp)
- Description: This solution implements a dynamic version of the union-find data structure and handles union and find operations efficiently.
- [Code](ass_3_sol_2.cpp)

### Solution 3: Finding Connected Components (ass_3_sol_3.cpp)
- Description: This solution finds connected components in an undirected graph using Depth-First Search (DFS).
- [Code](ass_3_sol_3.cpp)

### Solution 4: Range Updates and Point Queries (ass_3_sol_4.cpp)
- Description: This solution uses Binary Indexed Trees (BIT) to perform range updates and point queries efficiently.
- [Code](ass_3_sol_4.cpp)

### Solution 5: Prefix Sums with Range Updates (ass_3_sol_5.cpp)
- Description: This solution uses Binary Indexed Trees (BIT) to perform prefix sum queries with range updates.
- [Code](ass_3_sol_5.cpp)

## Assignment 4 Solutions

### Solution 1: Finding Bridges (ass_4_sol_1.cpp)
- Description: This solution finds bridges in an undirected graph using Depth-First Search (DFS).
- [Code](ass_4_sol_1.cpp)

## How to Use

1. Clone this repository to your local machine.
2. Navigate to the directory of the solution you want to run.
3. Compile the C++ file using a C++ compiler (e.g., g++).
4. Run the compiled executable to see the algorithm in action.

Feel free to modify and adapt the code according to your needs. Happy coding!
